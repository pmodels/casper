#! /usr/bin/env perl
#
# (C) 2014 by Argonne National Laboratory.
#     See COPYRIGHT in top-level directory.
#

use warnings;
use strict;
use Getopt::Long;

sub usage
{
    print "Usage: $0 --infile [input file] --outfile [output file] --append\n";
    exit 1;
}

my $infile = "";
my $outfile = "";
my $append = 0;

GetOptions(
    "infile=s" => \$infile,
    "outfile=s" => \$outfile,
    "append" => \$append
    ) or die "unable to parse options, stopped";

if (!$infile || !$outfile) {
    usage();
}

open(INFILE, "$infile");

# Check whether mpich-style header or openmpi-style header (mpich by default).
# Because each style uses slightly different format.
my $mpihstyle = "_mpich";
while (<INFILE>) {
    if (/define\s*OPEN_MPI/) {
        $mpihstyle = "_ompi";
        last;
    }
}
print "mpihstyle=$mpihstyle\n";

# Move to file beginning
seek INFILE, 0, 0;

# Goto the beginning prototype list
if ( $mpihstyle eq "_mpich" ) {
    while (<INFILE>) {
        if (/\/\*\s*Begin Prototypes/) { last; }
    }
} else {
    my $found = 0;
    while (<INFILE>) {
        # also skip the line after comment
        if (/\*\s*MPI API/) { $found = 1; next; }
        if ($found eq 1) { last; }
    }
}

my $eol = 1;
my $fullline = "";
my $tab = "    ";
my $retarg;
my $routine;
my $args;
my @arglist;
my $fname;
my $cdesc_routine;
my $x;
my $y;
my @argbits;
my $num_dtypes;
my @dtype_bind;


if ( !$append ) {
    open(CFILE, ">$outfile") || die "Could not open $outfile\n";
    print CFILE <<EOT;
/* -*- Mode: C; c-basic-offset:4 ; -*- */
/*
 *  (C) 2014 by Argonne National Laboratory.
 *      See COPYRIGHT in top-level directory.
 *
 * This file is automatically generated by buildiface
 * DO NOT EDIT
 */

#include "mpi.h"
#include "cspu.h"
EOT
} else {
    # Open file in append mode
    open(CFILE, ">>$outfile") || die "Could not open $outfile\n";
}


while (<INFILE>) {
    if ( $mpihstyle eq "_mpich" ) {
        if (/\/\*\s*End Prototypes/) { last; }

        if (/\/\*\s*Begin Skip Prototypes/) {
            while (<INFILE>) {
                if (/\/\*\s*End Skip Prototypes/) { last; }
            }
        }
    } else {
        if (/\*\s*Profiling MPI API/) { last; }
    }

    # If we found a semi-colon at the end, that's the end of the line.
    # This is not perfect (e.g., does not work when a single line has
    # multiple semi-colon separated statements), but should be good
    # enough for the MPICH mpi.h file
    if (/.*;$/) { $eol = 1; }
    else { $eol = 0; }

    chomp($_);
    $fullline .= "$_";
    if ($eol == 0) { next; }

    # We got the entire prototype in a single line

    # parse out comments
    $fullline =~ s+/\*.*\*/++g;

    # parse out attributes
    if ( $mpihstyle eq "_mpich" ) {
        $fullline =~ s/MPICH_ATTR_WEAK_ALIAS\(.*\)//g;
        $fullline =~ s/MPICH_ATTR_POINTER_WITH_TYPE_TAG\(.*\)//g;
    } else {
        $fullline =~ s/OMPI_DECLSPEC//g;
        $fullline =~ s/^\s+//;
        $fullline =~ s/__mpi_interface_deprecated__\(.*\)//g;
    }

    # split the line into the return type, routine name, and arguments
    $fullline =~ m/([^ ]*) ([^(]*)\((.*)\)/;
    $retarg = $1;
    $routine = $2;
    $args = $3;

    # cleanup args
    $args =~ s/\s\s*/ /g;
    $args =~ s/^\s*//g;
    $args =~ s/\s*$//g;

    # the following routines are ignored:
    # Comm_spawn should not be in this list
    if (($routine eq "MPI_Init")
        || ($routine eq "MPI_Win_allocate")
        || ($routine eq "MPI_Win_allocate_shared")
        || ($routine eq "MPI_Win_create")
        || ($routine eq "MPI_Win_create_dynamic")
        || ($routine eq "MPI_Comm_free")
        || ($routine eq "MPI_DUP_DN")
        || ($routine eq "MPI_Comm_disconnect")
        || ($routine eq "MPI_Comm_get_parent")
        || ($routine eq "MPI_Comm_join")
        || ($routine eq "MPI_Comm_spawn")
        || ($routine eq "MPI_Comm_spawn_multiple")
        || ($routine eq "MPI_DUP_FN")
        ## error handler related routines
        || ($routine eq "MPI_Comm_call_errhandler")
        || ($routine eq "MPI_Comm_create_errhandler")
        || ($routine eq "MPI_Comm_set_errhandler")
        || ($routine eq "MPI_Comm_get_errhandler")
        || ($routine eq "MPI_Errhandler_create")
        || ($routine eq "MPI_Errhandler_free")
        || ($routine eq "MPI_Errhandler_set")
        || ($routine eq "MPI_Errhandler_get")
        || ($routine eq "MPI_Win_call_errhandler")
        || ($routine eq "MPI_Win_create_errhandler")
        || ($routine eq "MPI_Win_set_errhandler")
        || ($routine eq "MPI_Win_get_errhandler")
        ## communicator construction routines
        || ($routine eq "MPI_Comm_dup")
        || ($routine eq "MPI_Comm_dup_with_info")
        || ($routine eq "MPI_Comm_idup")
        || ($routine eq "MPI_Comm_create")
        || ($routine eq "MPI_Comm_create_group")
        || ($routine eq "MPI_Comm_split")
        || ($routine eq "MPI_Comm_split_type")
        || ($routine eq "MPI_Cart_sub")
        || ($routine eq "MPI_Comm_free")
        || ($routine eq "MPI_Intercomm_create")
        || ($routine eq "MPI_Intercomm_merge")
        || ($routine eq "MPI_Cart_create")
        || ($routine eq "MPI_Graph_create")
        || ($routine eq "MPI_Comm_accept")
        || ($routine eq "MPI_Comm_connect")
        || ($routine eq "MPI_Dist_graph_create_adjacent")
        || ($routine eq "MPI_Dist_graph_create")
        ) {
        $fullline = "";
        next;
    }

    # skip MPIX_ routines
    if (!($routine =~ /MPI_/)) {
        next;
    }

    @arglist = split(/,/, $args);

    # If the function arguments have an MPI_Comm, it is of interest to
    # us.  Dump the function definition into the file and the function
    # name into the Makefile.

    my $comm_arg = -1;
    if (grep/MPI_Comm /, @arglist) {
        print CFILE "\n$retarg $routine(";
        for ($x = 0; $x <= $#arglist; $x++) {
            $arglist[$x] =~ s/^\s*//g;
            $arglist[$x] =~ s/\s*$//g;
        }

        for ($x = 0; $x <= $#arglist; $x++) {
            # remove variable names in arguments
            @argbits = split(/ /, $arglist[$x]);
            $arglist[$x] = "";
            for ($y = 0; $y <= $#argbits; $y++) {
                $argbits[$y] =~ s/\*.*/*/g;
                $argbits[$y] =~ s/[^ ]*\[\]/[]/g;
                if ($y < $#argbits) {
                    $arglist[$x] .= "$argbits[$y] ";
                }
                else {
                    if ($argbits[$y] =~ /\[\]/ || $argbits[$y] =~ /\*/) {
                        $arglist[$x] .= "$argbits[$y] ";
                    }
                    else {
                        # reduce the array size by one to drop the last bit
                        $#argbits--;
                    }
                }
            }

            @argbits = split(/ /, $arglist[$x]);

            if ($x) {
                print CFILE ", ";
            }

            # print out all but the last bit of the argument
            for ($y = 0; $y < $#argbits; $y++) {
                print CFILE "$argbits[$y] ";
            }

            # deal with [] structures for the last bit
            if (defined($argbits[$#argbits]) && $argbits[$#argbits] =~ /\[\]/) {
                print CFILE "x$x\[\]";
            }
            else {
                if (defined($argbits[$#argbits])) {
                    print CFILE "$argbits[$#argbits] x$x";
                }
            }
        }
        print CFILE ")\n{\n";

        # check and replace each comm input argument (no *)
        for ($x = 0; $x <= $#arglist; $x++) {
            if (grep/MPI_Comm $/, $arglist[$x]) {
                $comm_arg = $x;

                print CFILE "${tab}if (x$comm_arg == MPI_COMM_WORLD)\n";
                print CFILE "${tab}${tab}x$comm_arg = CSP_COMM_USER_WORLD;\n"
            }
        }

        print CFILE "${tab}return P$routine(";
        for ($x = 0; $x <= $#arglist; $x++) {
            print CFILE "x$x";
            if ($x == $#arglist) {
                print CFILE ");\n";
            }
            else {
                print CFILE ", ";
            }
        }

        print CFILE "}\n";
    }

    $fullline = "";
}
close CFILE;
