#! /usr/bin/env perl
#
# (C) 2014 by Argonne National Laboratory.
#     See COPYRIGHT in top-level directory.
#

use warnings;
use strict;
use Getopt::Long;

sub usage
{
    print "Usage: $0 --infile [input file] --outfile [output file]\n";
    exit 1;
}

my $infile = "";
my $outfile = "";

GetOptions(
    "infile=s" => \$infile,
    "outfile=s" => \$outfile
    ) or die "unable to parse options, stopped";

if (!$infile || !$outfile) {
    usage();
}

open(INFILE, "$infile");

while (<INFILE>) {
    if (/\/\*\s*Begin Prototypes/) { last; }
}

my $eol = 1;
my $fullline = "";
my $tab = "    ";
my $retarg;
my $routine;
my $args;
my @arglist;
my $fname;
my $cdesc_routine;
my $x;
my $y;
my @argbits;
my $num_dtypes;
my @dtype_bind;


open(CFILE, ">$outfile") || die "Could not open $outfile\n";
print CFILE <<EOT;
/* -*- Mode: C; c-basic-offset:4 ; -*- */
/*
 *  (C) 2014 by Argonne National Laboratory.
 *      See COPYRIGHT in top-level directory.
 *
 * This file is automatically generated by buildiface
 * DO NOT EDIT
 */

#include "mpi.h"
#include "mpiasp.h"
EOT


while (<INFILE>) {
    if (/\/\*\s*End Prototypes/) { last; }

    if (/\/\*\s*Begin Skip Prototypes/) {
        while (<INFILE>) {
            if (/\/\*\s*End Skip Prototypes/) { last; }
        }
    }

    # If we found a semi-colon at the end, that's the end of the line.
    # This is not perfect (e.g., does not work when a single line has
    # multiple semi-colon separated statements), but should be good
    # enough for the MPICH mpi.h file
    if (/.*;$/) { $eol = 1; }
    else { $eol = 0; }

    chomp($_);
    $fullline .= "$_";
    if ($eol == 0) { next; }

    # We got the entire prototype in a single line

    # parse out comments
    $fullline =~ s+/\*.*\*/++g;

    # parse out attributes
    $fullline =~ s/MPICH_ATTR_WEAK_ALIAS\(.*\)//g;
    $fullline =~ s/MPICH_ATTR_POINTER_WITH_TYPE_TAG\(.*\)//g;

    # split the line into the return type, routine name, and arguments
    $fullline =~ m/([^ ]*) ([^(]*)\((.*)\)/;
    $retarg = $1;
    $routine = $2;
    $args = $3;

    # cleanup args
    $args =~ s/\s\s*/ /g;
    $args =~ s/^\s*//g;
    $args =~ s/\s*$//g;

    # the following routines are ignored:
    # Comm_spawn should not be in this list
    if (($routine eq "MPI_Init")
        || ($routine eq "MPI_Win_allocate")
        || ($routine eq "MPI_Comm_free")
        || ($routine eq "MPI_DUP_DN")
        || ($routine eq "MPI_Comm_disconnect")
        || ($routine eq "MPI_Comm_get_parent")
        || ($routine eq "MPI_Comm_join")
        || ($routine eq "MPI_Comm_spawn")
        || ($routine eq "MPI_Comm_spawn_multiple")
        || ($routine eq "MPI_DUP_FN")
        ) {
        $fullline = "";
        next;
    }

    # skip MPIX_ routines
    if (!($routine =~ /MPI_/)) {
	next;
    }

    @arglist = split(/,/, $args);

    # If the function arguments have an MPI_Comm, it is of interest to
    # us.  Dump the function definition into the file and the function
    # name into the Makefile.

    my $comm_arg = -1;
    if (grep/MPI_Comm /, @arglist) {
        print CFILE "\n$retarg $routine(";
        for ($x = 0; $x <= $#arglist; $x++) {
            $arglist[$x] =~ s/^\s*//g;
            $arglist[$x] =~ s/\s*$//g;
        }

        for ($x = 0; $x <= $#arglist; $x++) {
            # remove variable names in arguments
            @argbits = split(/ /, $arglist[$x]);
            $arglist[$x] = "";
            for ($y = 0; $y <= $#argbits; $y++) {
                $argbits[$y] =~ s/\*.*/*/g;
                $argbits[$y] =~ s/[^ ]*\[\]/[]/g;
                if ($y < $#argbits) {
                    $arglist[$x] .= "$argbits[$y] ";
                }
                else {
                    if ($argbits[$y] =~ /\[\]/ || $argbits[$y] =~ /\*/) {
                        $arglist[$x] .= "$argbits[$y] ";
                    }
                    else {
                        # reduce the array size by one to drop the last bit
                        $#argbits--;
                    }
                }
            }

            @argbits = split(/ /, $arglist[$x]);

            if ($x) {
                print CFILE ", ";
            }

            # print out all but the last bit of the argument
            for ($y = 0; $y < $#argbits; $y++) {
                print CFILE "$argbits[$y] ";
            }

            # deal with [] structures for the last bit
            if ($argbits[$#argbits] =~ /\[\]/) {
                print CFILE "x$x\[\]";
            }
            else {
                print CFILE "$argbits[$#argbits] x$x";
            }

	    if ($comm_arg eq -1 && grep/MPI_Comm/, $arglist[$x]) {
		$comm_arg = $x;
	    }
        }
        print CFILE ")\n{\n";

	if ($comm_arg >= 0) {
	    print CFILE "${tab}if (x$comm_arg == MPI_COMM_WORLD)\n${tab}${tab}return P$routine(";
	    for ($x = 0; $x <= $#arglist; $x++) {
		if ($x == $comm_arg) {
		    print CFILE "MPIASP_COMM_USER_WORLD";
		}
		else {
		    print CFILE "x$x";
		}
		if ($x == $#arglist) {
		    print CFILE ");\n";
		}
		else {
		    print CFILE ", ";
		}
	    }
	    print CFILE "${tab}else\n${tab}${tab}return P$routine(";
	    for ($x = 0; $x <= $#arglist; $x++) {
		print CFILE "x$x";
		if ($x == $#arglist) {
		    print CFILE ");\n";
		}
		else {
		    print CFILE ", ";
		}
	    }
        }

        print CFILE "}\n";
    }

    $fullline = "";
}
close CFILE;
